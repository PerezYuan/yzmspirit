---
title: http爆炸重点学习——缓存
date: 2017-03-28 18:11:15
tags:
- http
categories: 前端技术
---

忙碌的三月，迟来的总结，今天写写http协议一个非常重要的点——缓存的处理。

<!-- more -->

> 缓存的作用是不言而喻的，它是web中各个方面性能优化的利器，关于http中的缓存，权威指南中的介绍非常直观：

> - 缓存减少了冗余的数据传输，节省了你的网络费用。

> - 缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。

> - 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。

> - 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。

其中也有一个最基本的概念：

> 可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存命中（cache hit），其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存未命中（cache miss）。

# 1.一图流
{% img /img/20170328.png 926 604 一图流 %}

上图中涉及到一些http首部字段，后面会慢慢讲到，首先我们可以把上图拆分成3种最简单的逻辑来分析。

## 1) 缓存未命中

分两种情况：
- 缓存必须要在浏览器访问过一次资源后才会产生，所以最简单的情况是第一次请求资源，直接从服务器上成功获取到资源，并设置一系列缓存相关的http头信息，如下图。

{% img /img/20170328_1.png 662 274 缓存未命中 %}

- 再次访问通过http首部字段验证不满足使用缓存的条件，如下图。

{% img /img/20170328_4.png 662 274 缓存未命中 %}

## 2) 缓存命中
- 缓存直接命中，这种情况也叫浏览器缓存命中（强缓存命中），这种直接返回状态码200（from cache）

{% img /img/20170328_2.png 662 274 缓存命中 %}


## 3) 缓存再验证命中
- 缓存再验证命中，这种也叫做协商缓存命中，在强缓存验证不通过的情况下，会像服务器端发送一个协商缓存验证的信息，如果此时服务器发现请求资源未修改，则返回状态码304（Not Modified）告知服务器从缓存中获取资源并更新协商缓存信息。这种情况通缓存未命中的第二种情况相对应。

{% img /img/20170328_3.png 662 274 缓存再验证命中 %}



# 2.浏览器缓存（强缓存）
下满我们来仔细讨论下http协议中缓存的机制，它是怎样通过一些首部信息来实现调用缓存的。从图中我们可以简单分析得出缓存包含两种类型，这两种类型我们叫做浏览器缓存（强缓存）和协商缓存，我们先讨论第一种缓存。

强缓存相关的首部字段：

| key | 描述 |
| ------------- |:-------------:| 
| Cache-Control | http1.1规则，优先级最高，可设置一系列缓存的机制 |
| Pragma | http1.0字段，指定缓存的方式，通常以no-cache出现 |
| Expires | http1.0字段，设定缓存的过期时间 |


## 1）Cache-Control

这个首部是缓存控制中最重要也是最常见的字段，它不仅可以设置缓存如何存储，同时也能告诉浏览器什么时候使用缓存，这个首部也是一个通用首部字段，在请求报文和响应报文都可以使用到，缓存指令是单向的, 这意味着在请求里设置的指令，在响应中不用包含相同的指令。

**Cache-Control**的语法为：`Cache-Control: cache-directive`。

- 在请求和响应都可能出现的指令：

| cache-directive | 描述 |
| --------------------- |:-------------------:| 
| max-age=[seconds] | 缓存请求的资源，该资源在second时间后缓存过期，单位为秒 |
| no-cache | 资源被缓存，但是立即失效，所有用户必须发送验证信息到服务器验证资源是否过期（协商） |
| no-store | 缓存不存储任何关于请求和响应的资源信息 |
| no-transform | 针对代理服务器，<br>让代理服务器不能对资源进行包括`Content-Encoding`<br>`Content-Range`<br>`Content-Type`header的修改，比如将图片资源的格式修改以便于压缩资源大小<br>的操作都会被这条指令阻止 |

- 只在请求中出现的指令：

| cache-directive | 描述 |
| --------------------- |:-------------------:| 
| max-stale[=seconds] | 可以使用已经失效的缓存，可设置时间控制在缓存失效之后second时间内仍然可以使用缓存 |
| min-fresh[=seconds] | 客户端希望获取到的资源至少有seconds的新鲜期 |
| only-if-cached | 如果有缓存就返回缓存，不和服务器交互，无缓存返回504（Gateway Timeout） |

- 只在响应中出现的指令：

| cache-directive | 描述 |
| --------------------- |:-------------------:| 
| must-revalidate | 缓存使用之前必须去验证新鲜度（协商），失败返回504（Gateway Timeout） |
| proxy-revalidate | 同上，适用于代理服务器 |
| public | 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存 |
| private | 表明响应只能被单个用户缓存（浏览器），不能作为共享缓存（即代理服务器不能缓存它） |
| s-maxage[=seconds] | 原理同max-age，适用于共享缓存（代理等），在共享缓存设置中会覆盖max-age和老一代Expires头 |

介绍跟时间设置相关的场景，假如一个资源在1月1日进行了缓存，当前的缓存周期是10天，即在1月10日资源会被再次验证新鲜度，那么我在1月1日有几种设计缓存的方案。

* Cache-Control: max-age=432000（5 * 24 * 3600 = 5day） 
该情况下，缓存周期为5天，缓存资源将在1月5日过期，无特殊情况下5天内都会去请求浏览器缓存的资源，而不会向服务器发送验证请求，原来的缓存周期会被覆盖。
* Cache-Control: max-stale =432000（5 * 24 * 3600 = 5day）
这种情况下，允许在缓存资源失效后5天内都可访问，即缓存资源会在1月15日过期。
* Cache-Control: min-fresh =86400（1 * 24 * 3600 = 1day）
这种情况下，缓存资源必须保留一天的新鲜度，即在1月9日就会去向服务器发送资源新鲜度验证请求。

> 当三种策略同时作用的时候，以最保守的情况做为依据，上述例子中，1月5日之后就会向服务器验证资源新鲜度了。在验证的策略后面会慢慢讲到。