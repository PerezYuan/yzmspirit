---
title: HTTPS应用&TLS握手机制
date: 2019-7-8 10:44:30
tags:
- http
categories: 前端技术
---

HTTPS，顾名思义，就是HTTP+S，而这个S是什么呢，它在HTTP的基础上有了什么变化，为什么需要HTTPS呢，就是本篇要讨论的东西了

<!-- more -->

我是一条可爱的分割线
***


> 首先我们来说一下这个S是什么？

S是指TLS安全协议，是在安全套接字SSL协议的基础上发展而来的，HTTP应用协议一起使用，相对于HTTP来说，给网络资源提供了一层保护层，保障万维网访问的安全性

#### 一、TLS工作的协议层  
* 在TCP/IP五层网络模型中，相当于在传输层和应用层之间加入了一层  
* 在ISO七层网络模型中，相当于表示层，在服务器和客户端之间协商一层数据密文传输和解析的方式

![TLS工作的协议层](https://tinashy-1256534403.cos.ap-chengdu.myqcloud.com/TLS%3ASSL%E6%89%80%E5%9C%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%B1%82.png)

#### 二、TLS层的作用
TLS层主要解决两个问题：

* 验证服务器的身份：服务器通过TLS层向客户端传递<a href="#da">数字证书</a>（点击可以查看介绍），客户端查验证书，可以知道与它通讯的服务器是不是别人冒充的。
* 保证传递信息的保密性：双方通过TLS层，约定对称加密算法和密钥，传输层传输的是密文，可以防止信息被中途窃听。

#### 三、TLS的工作原理

为了解决以上问题，TLS的工作过程可以分为两个阶段：

* 服务端客户端say hello的阶段 -- 验证服务器的身份

    1. client向server发出建立连接的请求（www.yzmspirit.com）,并一同发送一个client产生的随机数A，用于后面产生密钥的参数，以及client支持的散列算法和对称加密算法

    2. server收到连接请求后，也产生一个随机数B，发送给client，并选择一对server也支持的散列算法和对称加密算法，一起告知client
    
    3. server发送通过CA申请的证书给client，client验证证书的真实性，包括  
        - 通过证书的CA数字签名检查证书信息有没有被篡改或者替换
        - 证书是否在有效期内
        - 证书的申请者信息和domain域是否和server匹配  

	<pre style="color: #fff">验证通过，说明server身份真实，可以建立连接
	验证不通过，将不会继续接下来的工作，通过消息提示等告知用户server的身份很可疑</pre>
    
    4. 证书验证通过后，server通知客户端server_hello信息，表示hello阶段结束


至此，验证服务器身份的阶段完成了，接下来可以交流深层次的东西了，那当然就是密钥啦
  
* 产生密钥，交换密钥和验证密钥的阶段  --  传递信息的保密性

    1. server的证书里包含了server非对称加密密钥里的公钥，（常用的就是RSA非对称加密算法）client再次生成一个产生密钥的参数，就是随机数C，用公钥加密后，传递给server，server收到后用自己的私钥解密就得到了随机数C，这就保证了密钥参数里有一个的传递是保密的，不被窃听的，至于非对称加密怎么保证数据的安全性，文后的<a href="#sa">加密算法</a>有介绍  

    2. client通知server接下来交互的信息就要用约定的散列算法和加密算法处理信息了

    3. client用随机数A,B,C作为参数，用hello阶段与server约定好的加密算法的密钥生成方法，产生对称密钥Secret_key
    ，再用上述产生的所有参数和一些信息用约定的散列算法生成摘要H1，用密钥Secret_key加密H1后，发送给server，server用同样的方式生成对称密钥和摘要H2，解密收到的加密摘要H1，与H2对比，如果相等，说明生成的密钥可以正常使用，在加密传输的情况下，client发送正常，server接受正常

    4. server也回复client，接下来交互的信息就要用约定的散列算法和加密算法处理信息了

    5. server再次用上述产生的所有参数和一些信息用约定的散列算法生成摘要H3，用对称密钥加密H3后，发送给client，client用同样的方式验证，验证通过证明在加密传输的情况下，server发送正常，client也接受正常

至此，产生密钥，交换密钥和验证密钥的阶段的阶段也完成了，TLS的握手工作也就完成了  

接下来，当然就是server和client通过对称密钥愉快而又隐私的通信了

![TLS握手机制图解](https://tinashy-1256534403.cos.ap-chengdu.myqcloud.com/TLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png)

> HTTP和TLS是怎么配合工作的呢？

HTTPS其实就是HTTP与TLS配合工作的产物，以下两点可以说明：

* 上一节介绍了TLS的握手机制，其实就是代替了HTTP的三次握手阶段，TLS的握手加入了证书的验证，和密钥的产生，所以才让HTTPS有了安全可言
* TLS的握手阶段结束后，双方通信的方式就是HTTP协议了，只不过HTTP包里的实际数据内容是对称密钥加密后的密文，多了一个加密解密的过程

> 为什么需要HTTPS，与HTTP的区别是什么呢？

* HTTPS比HTTP更安全，建立在需要验证服务器身份和传递密文的基础上

* 但是正因为TLS做了很多额外的工作，HTTPS的建立连接和信息交互比HTTP更耗时，所以建议在需要安全性和保密性的网络服务上使用


## 附录

<span id="ds"></span> 
### 1. 数字签名  

* 数字签名的作用  
&ensp;&ensp;验证发送的信息中涂没有被篡改过，注意：信息没有加密，并不保证信息保密信息，如果信息需要保密，可以再全部加密后发送

* 数字签名的工作过程

![数字签名的工作图解](https://tinashy-1256534403.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png)

   1. 摘要（单向散列函数获取消息的散列值）和消息，一起用接收者的公钥加密后，发送
   2. 接收者用自己的私钥解密，计算消息的摘要（用同样的单向散列函数），和正文消息比对有无被篡改


<span id="da"></span> 
### 2. 数字证书  

&ensp;&ensp;要了解数字证书，首先得了解<a href="#ds">数字签名</a>

* 数字证书的作用  
&ensp;&ensp;验证发送者的身份和发送者的公钥可靠性

* 数字证书的工作过程

![数字证书的工作图解](https://tinashy-1256534403.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png)


 1. 申请者把公钥和申请信息一起发送给CA
 2. CA验证申请信息后提取申请者公钥和信息的摘要，用私钥加密摘要，形成CA的数字签名附在申请者公钥和信息的后面，就产生了数字证书，返回给申请者
 3. 申请者用CA的公钥解密数字证书，用同样的方式摘要信息，和解密信息对比，无误后此证书可用
 4. 申请者发送信息时，把数字证书附在后面一起发送给对方，对方利用缓存的CA根证书找到解密这个证书的数字签名，验证成功后得到发送者的公钥和申请信息，浏览器检查申请信息公司名字正常也没过期没问题，那么就证实了发送者的公钥没有问题，确实是可用的公钥，你用公钥解密对方的信息，成功解密就说明对方的身份正常，你就可以与他交互了，其实就是认证文件和公钥确实出于对方


<span id="sa"></span>
### 3. 加密算法  

* 非对称加密RSA  

  1. 选择一对不同的、足够大的素数p，q
  2. 计算n=pq
  3. 计算n的欧拉函数f(n)=f(p*q)=f(p-1)f(q-1)，同时对p, q严加保密，不让任何人知道
  4. 找一个与f(n)互质的数e，且1<e<f(n)
  5. 计算d，使得de%f(n)=1
  6. 公钥KU=(e,n)，私钥KR=(d,n)
  7. 加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为：
  C= M^e % n
  8. 解密过程为：
  M= C^d % n


* 对称加密AES  

  1. 密钥扩散轮：初始密钥矩阵->列位移->列混淆映射->与常量列异或->与第一列异或得第一列->第一列与第二列异或得第二列->第三列与第三列异或得第三列->。。。->扩散成第二个密钥矩阵
第二个密钥矩阵 -> 重复以上步骤->扩散成第三密钥矩阵重复，中间轮多少次就扩散多少个密钥矩阵

  2. 初始轮：
初始原文->原文矩阵->与初始密码矩阵异或->初始轮结果

  3. 中间轮：
初始轮结果->混淆矩阵：替代字节->行位移->列混淆->第二个密码矩阵->第二轮结果
重复n轮，n与密码矩阵长度相关，每轮用自己的密码矩阵 -> 最后加密矩阵

* 不可逆加密MD5  

&ensp;&ensp;MD5加密的过程是：把原文通过一个单向的散列函数映射成定长的字符输出，就叫这个原文的MD5码，hash算法在计算的过程中会丢弃原文的部分信息。

&ensp;&ensp;如果不同的原文产生了相同的MD5码，叫哈希碰撞，通过MD5码的长度来控制碰撞。

&ensp;&ensp;MD5不可逆的原因是hash函数一个单向密码体制，只有加密过程没有解密过程。

&ensp;&ensp;一般MD5码有128位2进制数，也就是有2^128种可能，理论上一个MD5是可以对应多个原文的，因为MD5是有限多个而原文是无限多个，这也是不可逆的原因之一，知道MD5码，绝不可能百分百确定原文。

&ensp;&ensp;MD5一般都用来加密用户密码


> 补充整理：HTTP的三次握手和四次挥手

* 三次握手  
    1. client发送TCP头带SYN=1标志的数据包给server，带随机产生的序列号seq1，请求建立连接
    2. server接收后，发送TCP头带SYN=1，ACK=seq1+1，标志的数据包，带随机产生的序列号seq2，给client
	<pre style="color: #fff">
	    验证client发送正常，server接受正常
	</pre>
  
    3. client接收ACK后，发送TCP头带ACK=seq2+1标志的数据包给client
    <pre style="color: #fff">
    验证client接收正常，server发送正常
    </pre>
     
SYN=1代表请求建立连接，ACK代表确认收到的数据包序号+1  

至此，三次握手才能验证client和server的发送接收都正常，接下来才可以开始正常的通信了

* 四次挥手  
    1. client发送TCP头带FIN=1标志的数据包给server，带随机产生的序列号seq3，单方面请求关闭client对server的连接
    
    2. server接收后，发送TCP头带ACK=seq3+1标志的数据包，给client
    <pre style="color: #fff">
    server确认client对server的话说完了，允许client关闭l，但是server对client的话还没说完，server单工发送给client，这种状态叫半关闭状态
    </pre>
    3. server发送TCP头带FIN=1标志的数据包给client，带随机产生的序列号seq4，请求关闭server对client连接

    4. client接收后，发送TCP头带ACK=seq4+1标志的数据包，给server  
    <pre style="color: #fff">
    client确认server对client的话说完了，允许server关闭，双方都关闭了，就是全关闭状态
    </pre>

FIN=1代表请求关闭连接，ACK代表确认收到的数据包序号+1  

至此，四次挥手才是双方都关闭了连接

> 参考 

[HTTPS协议详解(四)：TLS/SSL握手过程](https://www.cnblogs.com/huanxiyun/articles/6554085.html)

[通俗理解数字签名，数字证书和https](http://www.sohu.com/a/253770353_608959)

[一文搞懂 RSA 算法](https://www.jianshu.com/p/fbb8bf7baa97)

[十分钟读懂AES加密算法](https://blog.csdn.net/striner/article/details/85107921)

[MD5算法可以破解么？为什么？网上有在线破解是怎么回事？](https://blog.csdn.net/dawn_after_dark/article/details/54429766)

[TCP协议：三次握手过程详解](https://baijiahao.baidu.com/s?id=1618114723935605183&wfr=spider&for=pc)
















